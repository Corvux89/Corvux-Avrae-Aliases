def biting(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    biting = None
    dmg = sup.get_damage_str(attack)
    dc = 13 if args.last('biting') == 'True' else int(args.last('biting'))
    attack = attack.replace(f'{sup.get_damage_type(dmg)}', 'acid')
    a = load_json(attack)
    prop = sup.getProperties(attack)
    effect = {"type": "ieffect2", "name": "Disintegrated",
              "desc": "Dies immediately without making death saving throws.\n - A disintegrated creature and everything "
                      "unenhanced it is wearing or carrying are reduced to a pile of fine gray dust. A creature "
                      "destroyed in this way can not be revitalized."}

    if 'range' and 'reload' not in prop:
        auto = sup.get_on_hit_effects(attack)
        condition = {"type": "condition",
                     "condition": "target.hp <= 0 and lastSaveRollTotal < 13",
                     "onTrue": [effect],
                     "onFalse": []}
        text = {"type": "text", "title": "Biting", "text": "When you would make a melee weapon attack with a weapon with the biting property, you can instead force the target to make a Constitution saving throw (DC = 8 + your bonus to attacks with the weapon, or the biting number, whichever is lower). If you would have advantage on your attack roll, the creature instead has disadvantage on their saving throw, and if you would have disadvantage on your attack roll, the creature instead has advantage on their saving throw. On a failed save, the target takes normal weapon damage and is subjected to any additional effects that would occur on a hit, and the first attack it makes before the end of its next turn has disadvantage."}
        auto.append(condition)
        auto.append(text)
        save = {"type": "save", "stat": "con", "dc": f"{dc}", "fail": auto, "success": []}
        target = {"type": "target", "target": "each", "effects": [save]}
        biting = {"name": f"Biting - {a.name}", "_v": 2, "automation": [target]}
        biting = dump_json(biting)

    save = {"type": "save", "stat": "con", "dc": f"{dc}", "fail": [effect], "success": []}
    condition = {"type": "condition", "onFalse": []}

    if '"stat": "con"' in attack:
        condition["condition"] = "target.hp <= 0 and lastSaveRollTotal < 13"
        condition["onTrue"] = [effect]
    else:
        condition["condition"] = "target.hp <= 0"
        condition["onTrue"] = [save]

    for n in a.automation:
        if n.type == "target":
            for e in n.effects:
                if ('burst' or 'rapid' in a.name.lower()) and e.type == "save":
                    e.fail.append(condition)
                elif e.type == "attack":
                    e.hit.append(condition)
                    break

    return dump_json(a), biting

def bright(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    bright = None
    dmg = sup.get_damage_str(attack)
    dc = 13 if args.last('bright') == 'True' else int(args.last('bright'))
    attack = attack.replace(f'{sup.get_damage_type(dmg)}', 'fire')
    a = load_json(attack)
    prop = sup.getProperties(attack)

    if 'range' and 'reload' not in prop:
        auto = sup.get_on_hit_effects(attack)
        text = {"type": "text","title": "Bright", "text": "When you would make a melee weapon attack with a weapon with the bright property, you can instead force the target to make a Dexterity saving throw (DC = 8 + your bonus to attacks with the weapon, or the bright number, whichever is lower). If you would have advantage on your attack roll, the creature instead has disadvantage on their saving throw, and if you would have disadvantage on your attack roll, the creature instead has advantage on their saving throw. On a failed save, the target takes normal weapon damage and is subjected to any additional effects that would occur on a hit, and the creature takes additional damage of the same type at the start of its next turn equal to your governing ability modifier."}
        auto.append(text)
        save = {"type": "save", "stat": "dex", "dc": f"{dc}", "fail": auto, "success": []}
        target = {"type": "target", "target": "each", "effects": [save]}
        bright = {"name": f"Bright - {a.name}", "_v": 2, "automation": [target]}
        bright = dump_json(bright)

    return dump_json(a), bright

def corruption(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    corrupt = None
    dmg = sup.get_damage_str(attack)
    dc = 13 if args.last('corruption') == 'True' else int(args.last('corruption'))
    attack = attack.replace(f'{sup.get_damage_type(dmg)}', 'necrotic')
    a = load_json(attack)
    prop = sup.getProperties(attack)

    if 'range' and 'reload' not in prop:
        auto = sup.get_on_hit_effects(attack)
        text = {"type": "text","title": "Corruption", "text": "When you would make a melee weapon attack with a weapon with the corruption property, you can instead force the target to make a Wisdom saving throw (DC = 8 + your bonus to attacks with the weapon, or the corruption number, whichever is lower). If you would have advantage on your attack roll, the creature instead has disadvantage on their saving throw, and if you would have disadvantage on your attack roll, the creature instead has advantage on their saving throw. On a failed save, the target takes normal weapon damage and is subjected to any additional effects that would occur on a hit, and the creature cannot regain hit points until the start of your next turn."}
        auto.append(text)
        save = {"type": "save", "stat": "wis", "dc": f"{dc}", "fail": auto, "success": []}
        target = {"type": "target", "target": "each", "effects": [save]}
        corrupt = {"name": f"Corrupt - {a.name}", "_v": 2, "automation": [target]}
        corrupt = dump_json(corrupt)

    return dump_json(a), corrupt

def disarming(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    dc = f'8+{sup.get_attack_bonus(attack)}' if args.last('disarming') == 'True' else int(args.last('disarming'))
    a = load_json(attack)

    text = {"type": "text","title": "Disarming", "text": "When you score a critical hit with a weapon with the disarming property against a creature that is holding an object, you can attempt to disarm the target (no action required). If the target is no more than one size larger than you (your size or smaller if your weapon has the light property), it must succeed on a Strength saving throw (DC = 8 + your bonus to attacks with the weapon) or it drops an object of your choice at its feet."}
    save = {"type": "save", "stat": "str", "dc": f"{dc}", "fail": [], "success": []}
    condition = {"type": "condition", "condition": "lastAttackDidCrit == True", "onTrue": [save, text], "onFalse": []}

    for e in a.automation:
        if e.type == "target":
            for i in e.effects:
                if i.type == "attack":
                    i['hit'].append(condition)
                    break

    return dump_json(a)

def disintegrate(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    dc = 13 if args.last('disintegrate') == 'True' else int(args.last('disintegrate'))
    a = load_json(attack)

    text = {"type": "text", "title": "Disintegrate", "text": "When a creature is reduced to 0 hit points by a weapon with the disintegrate property, it must make a Constitution saving throw, DC equal to the disintegrate number. On a failed save, it dies immediately without making death saving throws. A disintegrated creature and everything unenhanced it is wearing or carrying are reduced to a pile of fine gray dust. A creature destroyed in this way can not be revitalized."}
    effect = {"type": "ieffect2", "name": "Disintegrated",
              "desc": "Dies immediately without making death saving throws.\n - A disintegrated creature and everything "
                      "unenhanced it is wearing or carrying are reduced to a pile of fine gray dust. A creature "
                      "destroyed in this way can not be revitalized."}

    save = {"type": "save", "stat": "con", "dc": f"{dc}", "fail": [effect], "success": []}
    condition = {"type": "condition", "onFalse": []}

    if '"stat": "con"' in attack:
        condition["condition"] = "target.hp <= 0 and lastSaveRollTotal < 13"
        condition["onTrue"] = [effect, text]
    else:
        condition["condition"] = "target.hp <= 0"
        condition["onTrue"] = [save, text]

    for n in a.automation:
        if n.type == "target":
            for e in n.effects:
                if ('burst' or 'rapid' in a.name.lower()) and e.type == "save":
                    e.fail.append(condition)
                elif e.type == "attack":
                    e.hit.append(condition)
                    break

    return dump_json(a)

def neuralizing(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    dc = 13 if args.last('neuralizing') == 'True' else int(args.last('neuralizing'))
    a = load_json(attack)

    text = {"type": "text", "title": "Neuralizing",
            "text": "When you hit a creature with a weapon with the neuralizing property, you can force it to make a Wisdom saving throw, DC equal to the neuralizing number. On a failed save, the creature takes an additional 1d4 psychic damage and becomes frightened of you until the start of its next turn."}
    effect = {"type": "ieffect2", "name": "Frightened",
              "desc": "A frightened creature has disadvantage on ability checks and attack rolls while the source of its fear is within line of sight.\n - The creature can’t willingly move closer to the source of its fear.\n - Source: {name}",
              "duration": 1}
    damage = {"type": "damage", "damage": "1d4 [psychic]"}

    save = {"type": "save", "stat": "wis", "dc": f"{dc}", "fail": [damage, effect], "success": []}

    for n in a.automation:
        if n.type == "target":
            for e in n.effects:
                if ('burst' or 'rapid' in a.name.lower()) and e.type == "save":
                    e.fail.append(save)
                    e.fail.append(text)
                elif e.type == "attack":
                    e.hit.append(save)
                    e.hit.append(text)
                    break

    return dump_json(a)

def shocking(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    dc = 13 if args.last('shocking') == 'True' else int(args.last('shocking'))
    a = load_json(attack)

    text = {"type": "text", "title": "Shocking",
            "text": "When you hit a creature with a weapon with the shocking property, you can force it to make a Dexterity saving throw, DC equal to the shocking number. On a failed save, the creature takes an additional 1d4 lightning damage and becomes shocked until the end of its next turn."}
    effect = {"type": "ieffect2", "name": "Shocked",
              "desc": "A shocked creature can’t take reactions.\n - On its turn, a shocked creature can take either an action or a bonus action, but not both.",
              "duration": 1,
              "end": True}
    damage = {"type": "damage", "damage": "1d4 [lightning]"}

    save = {"type": "save", "stat": "dex", "dc": f"{dc}", "fail": [damage, effect], "success": []}

    for n in a.automation:
        if n.type == "target":
            for e in n.effects:
                if ('burst' or 'rapid' in a.name.lower()) and e.type == "save":
                    e.fail.append(save)
                    e.fail.append(text)
                elif e.type == "attack":
                    e.hit.append(save)
                    e.hit.append(text)
                    break

    return dump_json(a)

def sonorous(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    dc = 13 if args.last('sonorous') == 'True' else int(args.last('sonorous'))
    a = load_json(attack)

    text = {"type": "text", "title": "Sonorous",
            "text": "When you hit a creature with a weapon with the sonorous property, you can force it to make a Constitution saving throw, DC equal to the sonorous number. On a failed save, the creature takes an additional 1d4 sonic damage and becomes deafened until the end of its next turn."}
    effect = {"type": "ieffect2", "name": "Deafened",
              "desc": "A deafened creature can’t hear and automatically fails any ability check that requires hearing.",
              "duration": 1,
              "end": True}
    damage = {"type": "damage", "damage": "1d4 [sonic]"}

    save = {"type": "save", "stat": "dex", "dc": f"{dc}", "fail": [damage, effect], "success": []}

    for n in a.automation:
        if n.type == "target":
            for e in n.effects:
                if ('burst' or 'rapid' in a.name.lower()) and e.type == "save":
                    e.fail.append(save)
                    e.fail.append(text)
                elif e.type == "attack":
                    e.hit.append(save)
                    e.hit.append(text)
                    break

    return dump_json(a)

def burst(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    a = load_json(attack)
    dmg = sup.get_damage_str(attack)
    bNum = 2 if args.last('burst') == 'True' else int(args.last('burst'))
    dc = f"8+{sup.get_attack_bonus(attack)}"
    on_hit = sup.get_on_hit_effects(attack)

    for e in on_hit:
        if e.type=="damage":
            e["damage"] = "{damage}"
            break
    save = {"type": "save", "stat": "dex", "fail": on_hit, "success": [], "dc": f"{dc}"}
    target = {"type": "target", "target": "all", "effects": [save]}
    counter = {"type": "counter", "counter": f"{sup.processName(a.name)}", "amount": f"{bNum}", "allowOverflow": False, "errorBehavior": "raise"}
    damage = {"type": "roll", "dice": f"{dmg}", "name": "damage"}
    text = {"type": "text", "text": f"{sup.getProperties(attack)}, burst {bNum}"}

    burst = {"name": f"Burst - {a.name}", "_v": 2, "automation": [damage, target, counter, text]}

    return dump_json(burst)

def rapid(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    a = load_json(attack)
    rNum = 2 if args.last('rapid') == 'True' else int(args.last('rapid'))
    dc = f"8+{sup.get_attack_bonus(attack)}"
    dtype = sup.get_damage_type(sup.get_damage_str(attack))
    die = sup.get_damage_die(attack)
    numDie = die[:die.find('d')]
    dieType = die[die.find('d')+1:]
    d_str = f"{int(numDie)*2}d{dieType} [{dtype}]"
    on_hit = sup.get_on_hit_effects(attack)
    for e in on_hit:
        if e.type=="damage":
            e["damage"] = d_str
            break
    counter = {"type": "counter", "counter": f"{sup.processName(a.name)}", "amount": f"{rNum}", "allowOverflow": False,
               "errorBehavior": "raise"}
    on_hit.append(counter)
    save = {"type": "save", "stat": "dex", "fail": on_hit, "success": [], "dc": f"{dc}"}
    target = {"type": "target", "target": "all", "effects": [save]}
    text = {"type": "text", "text": f"{sup.getProperties(attack)}, rapid {rNum}"}

    rapid = {"name": f"Rapid - {a.name}", "_v": 2, "automation": [target, text]}

    return dump_json(rapid)

def staggering(attack, args):
    using(sup="8b78365a-5c05-4c8f-8364-fbde2e3de862")
    dc = 13 if args.last('staggering') == 'True' else int(args.last('staggering'))
    a = load_json(attack)

    text = {"type": "text", "title": "Staggering Oscillator",
            "text": "When you hit with the weapon, you can force the target to make a DC 13 Strength saving throw. On a failed save, the creature is pushed back 10 feet and knocked prone.\nOnce you’ve used this feature, you must complete a short or long rest before you can use it again."}
    effect = {"type": "ieffect2", "name": "Prone",
              "buttons": [{"label": "Stand Up", "verb": "stands up", "automation": [{"type": "remove_ieffect"}]}],
              "duration": 1}

    save = {"type": "save", "stat": "str", "dc": f"{dc}", "fail": [effect], "success": []}

    for n in a.automation:
        if n.type == "target":
            for e in n.effects:
                if ('burst' or 'rapid' in a.name.lower()) and e.type == "save":
                    e.fail.append(save)
                    e.fail.append(text)
                elif e.type == "attack":
                    e.hit.append(save)
                    e.hit.append(text)
                    break

    return dump_json(a)