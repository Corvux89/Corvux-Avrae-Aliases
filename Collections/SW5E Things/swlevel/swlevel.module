# SWLevel Module

gvars = ["2f0a8c13-ad94-488f-9f1b-d44af24db1c4", "e917643b-768e-46e9-be26-c8d3b8ea5339"]
ch = character()
dagger = 'â€ '
image = ch.image
color = ch.csettings.color
footer = f"\"{ctx.prefix}swlevel v1.0 | @Corvux\""

def level(args):
    args = [x.lower() for x in args]
    dev = True if argparse(args).get('dev') else False

    remover = [args.remove(x) if x in args else None for x in
               ["practice", "engineering", "specialist", "technique", "pursuit", "order", "approach", "path", "form",
                "way", "of", "-cc", "-dev"]]
    inLevel = ([args.pop(args.index(x)) for x in args if x.isdigit()] + [''])[0]
    help = args and args[0] in ["help","?"]
    base = f'''embed -thumb {image} -color {color} -footer {footer} 
    -f "Total Level|{ch.levels.total_level}" '''
    classSearch = args[0] if args else None
    remover = args.remove(args[0]) if args else None
    archetypeSearch = args[0] if args else None
    err_str = []

    if not help:
        base += f''' -title "Level Summary for {ch.name}" '''
        # Initial Validation
        if inLevel and classSearch:
            for (cl, lvl) in ch.levels:
                if classSearch.lower() in cl.lower():
                    inLevel = None
                    err_str.append(
                        f"Cannot override class level|Your {cl} level is being set by your sheet. "
                        f"`{ctx.prefix}swlevel` can't alter this. You need to change your level on your sheet "
                        f"and `{ctx.prefix}update`")

        # Find information
        playerClass = getClass(classSearch)
        playerArchetype = getArchetype(playerClass, archetypeSearch)

        # Update CVARs
        updateCVARS(playerClass, playerArchetype, inLevel)

        # Hit Die
        hdStr = setupHD(playerClass, inLevel)
        hdStr = "\n".join(hdStr)

        base += f''' -f "Hit Die|{hdStr}|inline" '''

        # Total Levels
        c_str, total_levels = get_levels()
        base += f''' -f "Class Levels|{c_str}|inline" '''

        if total_levels > ch.levels.total_level:
            err_str.append(f"Invalid Total Level|Your total class levels exceed your character level. "
                           f"Remember to `{ctx.prefix}update` your sheet with your new level.")

        if dagger in c_str:
            err_str.append(f"Unrecognized Class|One or more classes imported from your sheet are marked with "
                           f"a dagger({dagger}). This means `{ctx.prefix}swlevel` does not recognize it and "
                           f"therefore cannot make counters or hit dice for it. You will have to set those up manually.")

        # Setup Counters
        counters = getCounters(playerClass, playerArchetype, inLevel)
        updateCounters(counters, inLevel)
        c_str = "\n".join([f'{x.name} ({ch.get_cc_max(x.name)}/{ch.cc(x.name).reset_on} rest)' for x in counters])
        base += f''' -f  "Counter{'s' if len(counters)>1 else ''}|{c_str}"'''

        for cl in playerClass:
            level = ch.levels.get(cl.Class) if not inLevel else int(inLevel)
            if level >= cl.get("subclassLevel") and cl.Class not in [x.Class for x in playerArchetype]:
                err_str.append(f"Don't forget your subclass!|One or more of your classes is high enough level "
                                f"to select a subclass, do so with `{ctx.prefix}swlevel <class> <archetype>`.")

        if ctx.author.id == 225752877316964352 and dev:
            actions = getActions(playerClass, playerArchetype, inLevel)
            updateActions(actions)
            return err({a.action.name for a in actions})

        # Error Strings
        if len(err_str) > 0:
            base += " -f " + " -f ".join([f"\"{x}\"" for x in err_str])

    else:
        base += f''' -title "{ctx.prefix}swlevel help!" -desc "Coming soon" '''

    if argparse(args).get('dev'):
        return err(base)

    ch.delete_cvar("swModCounters")
    return base

def options(args):
    args = [x.lower() for x in args]
    classSearch = args[0] if args else None
    base = f'''embed -thumb {image} -color {color} -footer {footer} -title "Available {'Archetypes' if classSearch else 'Classes'}" '''
    out_list = []

    for g in gvars:
        classes = load_json(get_gvar(g))

        if classSearch:
            out_list += list({x.get("subclass") for x in classes if classSearch.lower() in x.Class.lower() and x.get("subclass")})
            cl = list({x.get("Class") for x in classes if classSearch.lower() in x.Class.lower() and x.get("Class")})
            cl = cl[0] if len(cl) > 0 else ""
        else:
            out_list += list({x.Class for x in classes})

    if len(out_list) == 0:
        return err(f"**No class found matching that input.**\n"
                   f"Use `{ctx.prefix}swlevel options to see your available classes.")
    else:
        out_list.sort()
        base += f''' -f "{f'{cl} Subclasses:' if classSearch else 'Classes'}|{', '.join(out_list)}" '''

    return base

def getClass(str):
    classList = []

    # Manually Entered
    if str:
        for g in gvars:
            classes = load_json(get_gvar(g))

            for c in classes:
                if str and c.Class.lower() == str.lower() and not c.get("subclass") and c not in classList:
                    classList.append(c)

    if str and len(classList) == 0:
        return err("**No class found matching that input.**\n Use `!swlevel options` to see your available classes.")

    for g in gvars:
        classes = load_json(get_gvar(g))

        for c in classes:
            if not c.get("subclass"):

                # From Character sheet
                for (pc, lvl) in ch.levels:
                    if c.Class.lower() == pc.lower() and not c.get("subclass") and c not in classList:
                        classList.append(c)

                # Overrides
                if ch.get_cvar(f"{c.Class}Level") and c not in classList:
                    classList.append(c)

    if len(classList) == 0:
        return err("**No class found.**\n Use `!swlevel options` to see your available classes.")

    return classList


def get_levels():
    out_list = []
    total_level = 0
    ref_list = []

    for g in gvars:
        classes = load_json(get_gvar(g))
        ref_list += list({x.Class for x in classes if x.Class != "ExampleClass"})

    ref_set = {x: 0 for x in ref_list}

    for cl in ref_set:
        cl_str = None
        if ch.levels.get(cl):
            ref_set[cl]=ch.levels.get(cl)
            total_level += int(ch.levels.get(cl))
            cl_str = cl
        elif ch.get_cvar(f"{cl}Level"):
            ref_set[cl] = ch.get_cvar(f"{cl}Level")
            total_level += int(ch.get_cvar(f"{cl}Level"))
            cl_str = cl

        if ch.get_cvar("subclass") and load_json(ch.get_cvar("subclass")).get(f"{cl}Level"):
            cl_str += f" ({load_json(ch.get_cvar('subclass')).get(f'{cl}Level')})"

        out_list.append(f"{cl_str}: {ref_set[cl]}") if cl_str else ""

    for (cl, lvl) in ch.levels:
        if cl not in ref_set:
            out_list.append(f"{cl}{dagger}: {lvl}")

    cl_str = "\n".join(out_list)

    return cl_str, total_level


def getArchetype(playerClass, str):
    class_list = [y for y in {x.Class for x in playerClass}]
    archetype = []
    subclass = load_json(ch.get_cvar("subclass")) if ch.get_cvar("subclass") else {}
    for g in gvars:
        classes = load_json(get_gvar(g))

        for c in classes:
            if c.get("subclass") and c.Class in class_list and str and c.get("subclass").lower() == str.lower():
                archetype.append(c)
            elif c.get("subclass") and subclass.get(f"{c.Class}Level") == c.get("subclass"):
                archetype.append(c)

    return archetype


def updateCVARS(playerClass, playerArchetype, inLevel):
    subclass = load_json(ch.get_cvar("subclass", "{}"))
    subclass.update({f"{x.Class}Level": "" for x in playerClass if not subclass.get(f"{x.Class}Level")})

    if len(playerArchetype) > 0:
        for arch in playerArchetype:
            subclass[f"{arch.Class}Level"] = arch.subclass

    character().set_cvar("subclass", dump_json(subclass))

    for c in playerClass:
        if not ch.levels.get(c.Class) and inLevel:
            ch.set_cvar(f"{c.Class}Level", inLevel)


def getCounters(playerClass, playerArchetype, inLevel):
    counters = []

    for cl in playerClass:
        level = ch.levels.get(cl.Class) if not inLevel else int(inLevel)
        for counter in cl.counters:
            if level >= counter.level:
                counters.append(counter)

    if len(playerArchetype)>0:
        for arch in playerArchetype:
            level = ch.levels.get(arch.Class) if not inLevel else int(inLevel)
            for counter in arch.counters:
                if level >= counter.level:
                    counters.append(counter)
    return counters

def getActions(playerClass, playerArchetype, inLevel):
    actions = []

    for cl in playerClass:
        level = ch.levels.get(cl.Class) if not inLevel else int(inLevel)
        if cl.get('actions'):
            for action in cl.actions:
                if level >= action.level:
                    actions.append(action)

    if len(playerArchetype)>0:
        for arch in playerArchetype:
            level = ch.levels.get(arch.Class) if not inLevel else int(inLevel)
            if arch.get('actions'):
                for action in arch.actions:
                    if level >= action.level:
                        actions.append(action)
    return actions


def updateCounters(counters, inLevel):
    for counter in counters:
        # Class level
        level = min(int(ch.levels.get(counter.classLevel.replace("Level", ''))) if not inLevel else int(inLevel),20)

        # Max Value
        max_value = counter.value[level - 1] if typeof(counter.value) == 'SafeList' else counter.value.replace(f"{counter.classLevel}", f"{level}") if typeof(counter.value) == 'str' else counter.value

        # Max value modifier
        modifier = counter.modifier if 'modifier' in counter else 0
        modifier = modifier[level - 1] if typeof(modifier) == 'SafeList' else modifier.replace(f"{counter.classLevel}", f"{level}") if typeof(modifier) == 'str' else modifier

        # Reset on
        reset = counter.reset.split('$')
        reset = reset[0] if not '$' in counter.reset or level < int(reset[1]) else reset[2]

        # Create the counters
        ch.create_cc(counter.name, 0, f"{max_value}+{modifier}", reset, counter.display,
                     counter.get('reset_to'), None, None, counter.get('desc'))


def setupHD(playerClass, inLevel):
    hitDict = {"d6": 0, "d8": 0, "d10": 0, "d12": 0}
    out = []
    for cl in playerClass:
        level = int(ch.levels.get(cl.Class)) if not inLevel else int(inLevel)

        if cl.get("hitDie"):
            hitDict[cl.hitDie] += level

    for x in hitDict:
        if hitDict[x]:
            name = f"Hit Dice ({x})"
            if ch.cc_exists(name):
                ch.delete_cc(name)
            ch.create_cc_nx(name, 0, hitDict[x])

            out.append(f"{hitDict[x]}{x}")

    return out
