
Characters
Alias Workshop
Explore
My Subscriptions
My Work
Customization
My Customizations
Global Variables
Homebrew
Items
Spells
Creatures
Logout
Owned
Editable
Lookup
c3e74175-e7cd-49d4-be7a-f855db3c74b3
Gvar ID
c3e74175-e7cd-49d4-be7a-f855db3c74b3

Owned by: Derixyleth#0636

tembed <drac2>
parsed = argparse(args)
arguments = args
mode = 'help'
n = '\n'
ch = character()
sb = ch.spellbook
compact = parsed.last('h',parsed.last('compact',False))
counters = ch.consumables
counterNames = [x.name for x in counters]
hitDice = [f"d{x}" for x in range(20,0,-1)]
important = f''' -f "Important Note|In order to use Hit Dice with this alias, you must have at least one counter named `Hit Dice (d#)`, where # is the size of the Hit Die, such as `Hit Dice (d8)`. You can create it using the command below, or use the `!level` alias to automatically create Hit Dice counters for any and all of your class levels.{'`'*3}!cc create \\\"Hit Dice (d#)\\\" -min 0 -max ClassLevel{'`'*3}You need to **edit this command to use the appropriate __die size__ and __class level__.**\n\nIf you're multiclassing, we highly recommend using the `!level` alias to set up the Hit Dice counters in one go."'''
if arguments:
 for x in ["short","long","extrahd","default"]:
  if arguments[0].lower() in x:
   mode = x
   arguments.remove(arguments[0])
   break
if mode == 'long':
 restType = 'rest long'
 if arguments and arguments[0] in 'help?':
  outText = f'''-title "{name} has a Date with Prince Valium Tonight!" -desc "`!rest long` performs a Long Rest, resetting all counters that reset on a long or short rest, spell slots, hit points, temporary hitpoints, reducing exhaustion by 1 if the counter exists, and appropriately regaining Hit Dice." -f "Valid Arguments:|`-b #` - Regains extra hit dice.\n`-h|compact` - Hides pretty much all the extra counter text and condenses the embed into a more compact form.\n`armor` - Uses the variant rule from XGE where sleeping in armor recovers only one quarter your level in Hit Dice and doesn't reduce exhaustion."'''+important
 else:
  outText = f'-title "{name} takes a Long Rest!" -desc "Reset Death Saves'
  sleptInArmor = parsed.last('armor',False)
  hpGain = hp-character().hp
  tempHP = character().temp_hp
  character().set_hp(hp)
  character().set_temp_hp(0)
  outText += ', Hit Points' if compact else f'''" -f "Hit Points|{character().hp_str()}{f' ({hpGain:+})' if hpGain else ''}|inline"'''
  hitDieRate = int(max(1,level/(4 if sleptInArmor else 2)))+sum([int(b) for b in parsed.get('b')])
  hitDieText = ''
  for hd in hitDice:
   if (hitdie := f"Hit Dice ({hd})") in counterNames:
    hasHitDice = True
    if (delta :=  min(hitDieRate,ch.get_cc_max(hitdie)-ch.get_cc(hitdie))) and hitDieRate:
     hitDieRate -= delta
     ch.mod_cc(hitdie,delta)
     delta = f' ({delta:+})'
    hitDieText += f'**{hd}**: {ch.cc_str(hitdie)}{delta if delta else ""}{n}'
    delta = 0
  outText += (', Hit Dice' if compact else f' -f "Hit Dice|{hitDieText}|inline"') if get('hasHitDice') else ''
  if ch.cc_exists('Exhaustion'):
   if ch.get_cc('Exhaustion') and not sleptInArmor:
    exhaustionDecreased = True
    ch.mod_cc('Exhaustion',-1)
   outText += ', Exhaustion Level' if compact else f''' -f "Exhaustion|{ch.cc_str('Exhaustion')}{' (-1)' if get('exhaustionDecreased') else ''}|inline"'''
  if sum([sb.get_max_slots(slotLevel) for slotLevel in range(1,10)]):
   if exists('ssSpent'):
    ch.delete_cvar('ssSpent')
   spellSlotText = ''
   for slotLevel in range(1,10):
    if sb.get_max_slots(slotLevel):
     if delta := sb.get_max_slots(slotLevel)-sb.get_slots(slotLevel):
      delta = f' ({delta:+})'
     sb.set_slots(slotLevel,sb.get_max_slots(slotLevel))
     spellSlotText += character().spellbook.slots_str(slotLevel)+(delta if delta else '')+n
   outText += ', Spell Slots' if compact else f' -f "Spell Slots|{spellSlotText}|inline"'
  countersToResetO = {counter.name:{"reset_to":counter.reset_to,"reset_by":counter.reset_by} for counter in counters if counter.reset_on and counter.reset_on in 'shortlong' and counter.name.lower()!='exhaustion'}
  if countersToResetO:
   countersToResetList = list(countersToResetO)
   countersToResetList.sort()
   countersToReset = {}
   countersToReset.update({x:countersToResetO[x] for x in countersToResetList})
   counterFields = ['' for i in range(20)]
   counterField = 0
   for counter in countersToReset:
    if delta := countersToReset[counter].reset_by:
     if ('-' in delta and ch.get_cc(counter) == ch.get_cc_min(counter)) or (not '-' in delta and ch.get_cc(counter) == ch.get_cc_max(counter)):
      delta = ''
     else:
      delta = vroll(countersToReset[counter].reset_by)
      ch.mod_cc(counter,delta.total)
      delta = f' ({delta})'
      if 'd' in delta:
       delta = delta.replace(' `',' `+') if not '-' in delta[:-6] else delta
      else:
       delta = delta[:delta.index('=')-1]+')'
    elif countersToReset[counter].reset_to is not None and (delta := countersToReset[counter].reset_to-ch.get_cc(counter)):
     ch.mod_cc(counter,delta)
     delta = f' ({delta:+})'
    elif countersToReset[counter].reset_to is None and (delta := ch.get_cc_max(counter)-ch.get_cc(counter)):
     ch.mod_cc(counter,delta)
     delta = f' ({delta:+})'
    counterText = counter+(f'{delta if delta else ""}, ' if compact else f''': {ch.cc_str(counter)}{delta if delta else ""}{n}''')
    counterField += 1 if len(counterFields[counterField]+counterText)>1020 else 0
    counterFields[counterField] += counterText
   counterFields = [field.strip(', ') for field in counterFields if field]
   outText += (', ' if compact else ' -f "Reset Counters|')+'" -f "Continued|'.join(counterFields)+'"'
elif mode == 'short' or mode == 'extrahd':
 s = mode=='short'
 restType = 'rest short' if s else 'rest extra'
 if arguments and arguments[0] in 'help?':
  outText = f'''-title "{name} {'could use a break' if s else 'needs five more minutes'}!" -desc "`!{restType}` {'performs a Short Rest,' if s else 'spends additional Hit Dice without'} resetting counters that reset on a short rest{',' if s else ' or'} regaining spell slots for warlocks{', and spending Hit Dice if told to' if s else ''}." -f "Valid Arguments:|`XdY` - Spends X dY Hit Dice, e.g. `!{restType} 3d8` will spend 3 d8 Hit Dice to heal you. Now supports multiple die types at once, so you can do `!{restType} 1d12 2d10` to roll 1 d12 and 2 d10 Hit Dice for healing.\nYou can also just do `!{restType} X` to use X Hit Dice, starting with the largest available to you. If you want to set a default primary Hit Die size to use first that isn't your largest available, create a cvar named `defaultHD` and set it to a die type, e.g. `!cvar defaultHD d8`. You can also use `!rest default dX` to set your default Hit Die size.\n`-b XdY` - Adds extra dice to your healing roll without using Hit Dice, typically for use when you are resting with a bard and are affected by their Song of Rest, e.g. `!{restType} 3d8 -b 1d6` will spend 3 d8 Hit Dice and add a bonus d6 to your healing roll.\n`max` - Rolls the maximum value for each Hit Die rolled. Does not apply to bonus healing."'''+important+f' -f "Automatically Accounted For Options|**Durable Feat:** If you have the Durable feat, create a cvar named `feats` and put `Durable` in it (or use the `!manage` alias; `!manage feats add durable`). You can also just use the `dur` or `durable` argument with the alias to apply the effect.\n\n**Bard: Song of Rest:** When you have levels in bard, this alias will automatically apply your personal Song of Rest bonus healing when you spend Hit Dice on a short rest (but not when you spend additional Hit Dice with `!rest extra`, also note that your party members still need to use `-b` as above).\n\n**Periapt of Wound Closure:** If you have a Periapt of Wound Closure, create a cvar named `attunedItems` and put `Periapt of Wound Closure` in it (or use the `!manage` alias; `!manage attune add \\\"Periapt of Wound Closure\\\"). You can also use the `periapt` or `closure` argument with the alias to apply the effect." -f "**Verdan: Black Blood Healing:** If your race is set as Verdan (either on your sheet or through the `!setrace` alias, `!{restType}` will automatically reroll any 1s or 2s you roll on a Hit Die."'
 else:
  Bardness = int(get('BardLevel',1))-1
  Warlockness = int(get('WarlockLevel',0))
  yourRace = get("race",ch.race)
  Verdan = "ro<3" if yourRace.lower()=='verdan' else ""
  spentDice = []
  maxed = parsed.last('max',False)
  durable = 'durable' in get('feats','').lower() or parsed.last('durable',parsed.last('dur',False))
  periapt = 'periapt of wound closure' in get('attunedItems','').lower() or parsed.last('periapt',parsed.last('closure',False))
  ownedHitDice = []
  regenValid=False
  if 'regen' in arguments:
   regenValid = ch.cc_exists("Regeneration") and ch.get_cc("Regeneration") and yourRace.lower() in ['newt beastling','salamander beastling']
   if regenValid:
    ch.mod_cc("Regeneration",-1)
  for hd in hitDice:
   if (hitdie := f"Hit Dice ({hd})") in counterNames:
    ownedHitDice.append(hitdie)
    if '-b' in arguments:
     arguments = arguments[:arguments.index('-b')]
    for arg in arguments:
     if 'd' in arg and hd == arg[arg.index('d'):]: # and arguments[arguments.index(arg)-1] != '-b': # not arg in parsed.get('b'):
      spentDice.append({"size":hd,"counter":f"Hit Dice ({hd})","numberSpent":min(int(arg.split('d')[0] if arg.split('d')[0] else arguments[arguments.index(arg)-1] if arguments.index(arg) and arguments[arguments.index(arg)-1].isdigit() else 1),ch.get_cc(f"Hit Dice ({hd})"))})
  if arguments and (arguments[0].isdigit() or regenValid) and ownedHitDice and not spentDice:
   totalDice =  1 if regenValid else int(arguments[0])
   defaulthd = f"Hit Dice ({get('defaultHD',ownedHitDice[0][ownedHitDice[0].index('d'):-1])})"
   hitDieList = [defaulthd]+[die for die in ownedHitDice if die!=defaulthd]
   for hitdie in hitDieList:
    if totalDice <= 0:
     break
    if ch.cc_exists(hitdie) and ch.get_cc(hitdie):
     hd = hitdie[hitdie.index('d'):-1]
     spentDice.append({"size":hd,"counter":hitdie,"numberSpent":min(totalDice,ch.get_cc(hitdie))})
     totalDice -= ch.get_cc(hitdie)
  spentDiceString = (', ' if len(spentDice)!=2 else ' and ').join([f"{'and ' if len(spentDice)>2 and spentDice[spentDice.index(die)]==spentDice[-1] else ''}{die.numberSpent} {die.size}" for die in spentDice]) or 0
  hdRolls = [vroll(f"{die.numberSpent}{die.size.replace('d','*' if maxed else 'd')}{Verdan}{f'mi{max(2,constitutionMod*2)}[durable]' if durable else ''}{'*2[Periapt of Wound Closure]' if periapt else ''}+{die.numberSpent*constitutionMod}") for die in spentDice]
  for die in spentDice:
   ch.mod_cc(die.counter,-die.numberSpent)
  hpGain = sum([Roll.total for Roll in hdRolls])
  bonus = ([f"1d{2*(3+(Bardness>7)+(Bardness>11)+(Bardness>15))}[Song of Rest]"] if Bardness and spentDiceString and s else [])+parsed.get('b') if hpGain else []
  bonusText = f', along with {(", " if len(bonus)!=2 else " and ").join([("and " if len(bonus)>2 and bonus[bonus.index(value)]==bonus[-1] else "")+value[:value.index("[") if "[" in value else None] for value in bonus])} bonus healing' if bonus else ''
  bonusRolls = [vroll(value) for value in bonus]
  hpGain += sum([Roll.total for Roll in bonusRolls])
  ch.modify_hp(hpGain,0,0)
  outText = (f' -title "{name} {"" if regenValid else "tries to "}use{"s" if regenValid else ""} their {yourRace.title().split()[0]} Regeneration feature as a Bonus Action!"' if 'regen' in arguments else f' -title "{name} {"takes" if s else "spends additional Hit Dice during"} a Short Rest!"')+(f' -desc "{name} spends {spentDiceString}{"" if s or regenValid else " extra"} hit di{"c" if sum([die.numberSpent for die in spentDice])!=1 else ""}e{bonusText}, recovering a total of {hpGain} hit points."' if not 'regen' in arguments or regenValid else ' -desc "You lack any uses of this feature."') if ownedHitDice else f''' -title "{name} hasn't set up hit dice yet." -desc "See `!rest help` for instructions on how to set up hit dice."'''
  outText += f' -f "Healing|{n.join([str(Roll) for Roll in hdRolls])}|inline"' if hpGain else ''
  outText += f' -f "Bonus Healing|{n.join([str(Roll) for Roll in bonusRolls])}|inline"' if bonus else ''
  if s:
   countersToResetO = {counter.name:{"reset_to":counter.reset_to,"reset_by":counter.reset_by} for counter in counters if counter.reset_on and counter.reset_on in 'short'}
   if countersToResetO:
    countersToResetList = list(countersToResetO)
    countersToResetList.sort()
    countersToReset = {}
    countersToReset.update({x:countersToResetO[x] for x in countersToResetList})
    counterFields = ['' for i in range(20)]
    counterField = 0
    for counter in countersToReset:
     if delta := countersToReset[counter].reset_by:
      if ('-' in delta and ch.get_cc(counter) == ch.get_cc_min(counter)) or (not '-' in delta and ch.get_cc(counter) == ch.get_cc_max(counter)):
       delta = ''
      else:
       delta = vroll(countersToReset[counter].reset_by)
       ch.mod_cc(counter,delta.total)
       delta = f' ({delta})'
       if 'd' in delta:
        delta = delta.replace(' `',' `+') if not '-' in delta[:-6] else delta
       else:
        delta = delta[:delta.index('=')-1]+')'
     elif countersToReset[counter].reset_to is not None and (delta := countersToReset[counter].reset_to-ch.get_cc(counter)):
      ch.mod_cc(counter,delta)
      delta = f' ({delta:+})'
     elif countersToReset[counter].reset_to is None and (delta := ch.get_cc_max(counter)-ch.get_cc(counter)):
      ch.mod_cc(counter,delta)
      delta = f' ({delta:+})'
     counterText = counter+f'{delta if delta else ""}, '
     counterField += 1 if len(counterFields[counterField]+counterText)>1020 else 0
     counterFields[counterField] += counterText
    counterFields = [field.strip(', ') for field in counterFields if field]
    outText += ' -f "Reset Counters|'+'" -f "Continued|'.join(counterFields)+'"'
   if Warlockness:
    W = int(WarlockLevel)
    slotLevel = min(ceil(W/2),5)
    totalSlots = sb.get_max_slots(slotLevel)
    pactSlots = (W>0)+(W>1)+(W>10)+(W>16)
    standardSlots = totalSlots - pactSlots
    if standardSlots:
     ch.set_cvar('ssSpent', max(0,standardSlots - sb.get_slots(slotLevel),int(get('ssSpent',0))))
    delta = min(sb.get_max_slots(slotLevel)-sb.get_slots(slotLevel)-int(get('ssSpent',0)),pactSlots)
    sb.set_slots(slotLevel,min(delta+sb.get_slots(slotLevel),sb.get_max_slots(slotLevel)))
    outText += f' -f "Spell Slots|{sb.slots_str(slotLevel)}{f" ({delta:+})" if delta else ""}"'
  hitDieText = ''
  for hitdie in ownedHitDice:
   delta = 0
   for dice in spentDice:
    if hitdie==dice.counter:
     delta = f" (-{dice.numberSpent})"
   hitDieText += f'**{hitdie[hitdie.index("d"):-1]}**: {character().cc_str(hitdie)}{delta if delta else ""}{n}'
  outText += f' -f "Hit Dice|{hitDieText}|inline"' if ownedHitDice else ''
  outText += f' -f "{yourRace} Regeneration|{ch.cc_str("Regeneration")}|inline"' if get('regenValid') else ''
elif mode == 'default':
 restType = 'rest default'
 if arguments and (arguments[0] in 'help?' or not arguments[0] in hitDice) or not arguments:
  outText = f''' -title "{name} needs help..." -desc "This is the `default` mode. You can set a Default Hit Die size to use when you short rest or spend additional Hit Dice without specifying a Hit Die size. The syntax is `!rest default dX`, replace the `X` with a number appropriate for a Hit Die your character possesses."'''
 ownedHitDice = []
 for hd in hitDice:
  if (hitdie := f"Hit Dice ({hd})") in counters:
   ownedHitDice.append(hitdie)
 for hd in ownedHitDice:
  if arguments and arguments[0] in hd:
   character().set_cvar("defaultHD",hd[hd.index('d'):-1])
   outText = f''' -title "{name} sets their Default Hit Die to a {hd}!" -desc "Until you change it, your prioritized Hit Die will be a {hd} whenever you do a short rest or spend additional Hit Dice without specifying a Hit Die size."'''
   break
 if not get('outText',''):
  outText = f''' -title "{name} dun goofed!" -desc "You don't have a {arguments[0]} Hit Die available to you. Please try again."'''
elif mode == 'help':
 outText = ''' -title "To Rest, Perchance to Dream..." -desc "We got short rests, we got long rests, we got extra hit dice expenditure during a short rest, we got multiple sizes of Hit Dice to spend during a short rest, we got everything you need here! Take a load off and have a rest, my friend!" -f "Short Rest|`!rest short` - Takes a short rest. Valid arguments can be found with `!rest short help`.\nTo spend additional hit dice during a short rest without triggering the regaining of warlock spell slots or any other features that reset on a short rest, use `!rest hd` or `!rest extra` to only spend hit dice. Use `!rest extra help` to see the arguments available there (they're the same as for short rest though).\n`!rest default Xd` - Sets a default Hit Die size to use when short resting." -f "Long Rest|`!rest long` - Takes a long rest. Valid arguments can be found with `!rest long help`."'''+important
 restType = ''
return outText+f' -thumb {image} -color {color} -footer "{f"{name}: <{character().hp_str()}> | !{restType} ? - help | " if restType else ""}vII.2a"'
</drac2>
©2022 D&D Beyond | All Rights Reserved
Dungeons & Dragons, D&D, their respective logos, and all Wizards titles and characters are property of Wizards of the Coast LLC in the U.S.A. and other countries. ©2022 Wizards.
Privacy PolicyGeneral TermsSupport
